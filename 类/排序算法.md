## 排序算法

### 选择排序

#### 思想
![本地路径](选择排序.png "相对路径演示")
红色底色的块代表着当前进行遍历的list。红色字体的数字为当前list中的最大项，蓝色字体的数字为当前list中最大项应该在的位置。
#### code
```python
def selectionSort(array):
    n = len(array)
    for i in range(n-1,0,-1):
        maxIdx = i
        for j in range(0,i):
            if array[j] > array[maxIdx]:
                maxIdx = j
        swapElement(array,maxIdx,i)

def swapElement(array,x,y):
    temp = array[x]
    array[x] = array[y]
    array[y] = temp
```

### 插入排序

#### 思想
![本地路径](插入排序.png "相对路径演示")
#### code
```python
def insertionSort(array):
    n = len(array)

    for i in range(1,n):
        next_ = array[i]
        j = i-1

        while j>=0 and array[j]>next_:
            array[j+1] = array[j]
            j=j-1
        array[j+1]=next_
```

### 冒泡排序

#### code
```python
def bubbleSort(array):
    n = len(array)

    for i in range(n-1,0,-1):
        for j in range(1,i+1):
            if array[j-1]>array[j]:
                swapElement(array,j,j-1)
```
#### Better Version
```python
def bubbleSort(array):
    n = len(array)

    for i in range(n-1,0,-1):
        isSorted = True


        for j in range(1,i+1):
            if array[j-1]>array[j]:
                swapElement(array,j,j-1)
                isSorted = False
        
        if isSorted:
            return
```
对于原版的冒泡排序算法，时间复杂度一直都是O(n^2^)。

Better Version这一版，最坏的情况下的时间复杂度是O(n^2^)，最好的情况下时间复杂度为O(n)。

### 归并排序

#### 思想

#### code
```python
def mergeSort(array,low,high):
    if low<high:
        mid = (low+high)//2

        mergeSort(array,low,mid)
        mergeSort(array,mid+1,high)

        merge(array,low,mid,high)

def merge(array,low,mid,high):
    n = high-low+1
    result = []
    left = low
    right = mid+1

    while left<=mid and right <=high:
        if array[left] <=array[right]:
            result.append(array[left])
            left+=1
        else:
            result.append(array[right])
            right+=1
    while left <= mid:
        result.append(array[left])
        left+=1

    while right<=high:
        result.append(array[right])
        right+=1
    for k in range(0,n):
        array[low+k] = result[k]

def mergeSortHelper(array):
    mergeSort(array,0,len(array)-1)
```

### 快排

```python
def swapElement(array,x,y):
    temp = array[x]
    array[x] = array[y]
    array[y] = temp

def quickSort(array,low,high):
    if low < high:
        pivotIdx = partition(array,low,high)

        quickSort(array,low,pivotIdx-1)
        quickSort(array,pivotIdx+1,high)
def partition(array,i,j):
    pivot = array[i]
    middle = i

    for k in range(i+1,j+1):
        if array[k] < pivot:
            middle = middle+1
            swapElement(array,k,middle)
    swapElement(array,i,middle)
    return middle
```


### Radix Sort(基数排序)
这种排序不需要比较
```python
def radixSort(array):
    numDigit = int(math.log10(max(array))) +1

    for power in [10**i for i in range(numDigit)]:
        digitBin = [[] for d in range(10)]
        distribute(array,digitBin, power)
        collect(digitBin,array)
def distribute(array,digitBin,power):
    for item in array:
        digit = (item//power) %10
        digitBin[digit].append(item)
def collect(digitBin,array):
    startIdx = 0
    for eachBin in digitBin:
        array[startIdx:] = eachBin
        startIdx += len(eachBin)
```